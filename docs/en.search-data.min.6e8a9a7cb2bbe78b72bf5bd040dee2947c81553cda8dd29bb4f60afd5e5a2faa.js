'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/1.algorithm/','title':"I. 算法",'section':"Docs",'content':"I. 算法 #  "});index.add({'id':1,'href':'/docs/1.algorithm/binary-tree/','title':"二叉树",'section':"I. 算法",'content':"二叉树 #  二叉树 (Binary tree) 是每个节点最多只有两个分支的树结构。其结构定义如下：\nclass TreeNode: def __init__(self, value, left=None, right=None): self.value = value self.left = left self.right = right def visit(self): print(self.value, end=\u0026#34; \u0026#34;) # 访问当前结点 遍历 #  树的遍历 是图的遍历的一种，指的是按照某种规则，不重复地访问某种树的所有节点的过程。\n遍历可分为 深度优先遍历 和 广度优先遍历，深度优先遍历又分为 前序遍历 (Pre-Order Traversal)、中序遍历 (In-Order Traversal)、后序遍历 (Post-Order Traversal)；而广度优先搜索则对应 层序遍历。\n测试树如下：\n A / \\ B C / \\ / \\ D E F G / \\ H I 正确的前序遍历： A B D E C F H I G 正确的中序遍历： D B E A H F I C G 正确的后序遍历： D E B H I F G C A 正确的层序遍历： A B C D E F G H I test = TreeNode(\u0026#39;A\u0026#39;, left=TreeNode(\u0026#39;B\u0026#39;, left=TreeNode(\u0026#39;D\u0026#39;), right=TreeNode(\u0026#39;E\u0026#39;)),right=TreeNode(\u0026#39;C\u0026#39;, left=TreeNode(\u0026#39;F\u0026#39;, left=TreeNode(\u0026#39;H\u0026#39;), right=TreeNode(\u0026#39;I\u0026#39;)), right=TreeNode(\u0026#39;G\u0026#39;))) 递归形式 #  前序遍历 def preorder(node: TreeNode): if node is None: return node.visit() # 访问当前结点 preorder(node.left) preorder(node.right) 中序遍历 def inorder(node: TreeNode): if node is None: return inorder(node.left) node.visit() # 访问当前结点 inorder(node.right) 后序遍历 def postorder(node: TreeNode): if node is None: return postorder(node.left) postorder(node.right) node.visit() # 访问当前结点  迭代形式 #  栈模拟递归 #  前序遍历 1 def preorder_iter(root: TreeNode): if root is None: return stack = [root] while stack: node = stack.pop() if node is None: continue node.visit() # 访问当前结点 stack.append(node.right) # 先入栈右子树 stack.append(node.left) # 再入栈左子树 后序遍历 1 后序遍历 1：类前序遍历 1 + reverse：先用栈模拟，再利用双栈将 根-右-左 的结果反过来\ndef postorder_iter(root: TreeNode): if root is None: return stack = [root] res = [] while stack: node = stack.pop() if node is None: continue res.append(node) stack.append(node.left) # 先入栈左子树 stack.append(node.right) # 再入栈右子树 for node in reversed(res): node.visit()  迭代遍历模板 #  前序遍历 2 def preorder_iter2(root: TreeNode): if root is None: return stack = [] node = root while node or stack: while node: # 先找最左的 node，路途依次入栈 node.visit() # 根 stack.append(node) node = node.left # 左 node = stack.pop() node = node.right # 右 中序遍历 def inorder_iter(root: TreeNode): if root is None: return stack = [] node = root while node or stack: while node: # 先找最左的 node，路途依次入栈 stack.append(node) node = node.left # 左 node = stack.pop() node.visit() # 根 node = node.right # 右 后序遍历 2 后序遍历 2：类前序遍历 2 + reverse：先用树的非递归模板，再利用双栈将 根-右-左 的结果反过来\ndef postorder_iter2(root: TreeNode): if root is None: return stack, res = [], [] node = root while node or stack: while node: # 先找最右的 node，路途依次入栈 res.append(node) # 根 stack.append(node) node = node.right # 右 node = stack.pop() node = node.left # 左 for node in reversed(res): node.visit() 层序遍历 def levelorder_iter(root: TreeNode): if root is None: return queue = [root] while queue: node = queue.pop(0) node.visit() if node.left is not None: queue.append(node.left) if node.right is not None: queue.append(node.right)  "});index.add({'id':2,'href':'/docs/1.algorithm/sorting/','title':"排序",'section':"I. 算法",'content':"排序 #  堆排序 #  堆排序的平均和最差情况时间均为   \\(O(n \\log n)\\)  ，空间为  \\(O(1)\\)  递归形式 def heap_sort(nums: list) -\u0026gt; list: def adjust(heap: list, start, end): left = start * 2 + 1 right = left + 1 if left \u0026gt;= end: return max_child = right if right \u0026lt; end and heap[left] \u0026lt; heap[right] else left # 选取最大的子结点 if heap[start] \u0026lt; heap[max_child]: heap[start], heap[max_child] = heap[max_child], heap[start] adjust(heap, max_child, end) # 从最后一个结点的父结点开始建堆 for i in reversed(range(len(nums) // 2)): adjust(nums, i, len(nums)) # 将最大结点交换至最后并调整堆 for i in reversed(range(len(nums))): nums[0], nums[i] = nums[i], nums[0] adjust(nums, 0, i) return nums 迭代形式 def heap_sort_iter(nums: list) -\u0026gt; list: def adjust(heap: list, start, end): while start \u0026lt; end: left = start * 2 + 1 right = left + 1 if left \u0026gt;= end: break max_child = right if right \u0026lt; end and heap[left] \u0026lt; heap[right] else left # 选取最大的子结点 if heap[start] \u0026gt;= heap[max_child]: break heap[start], heap[max_child] = heap[max_child], heap[start] start = max_child # 从最后一个结点的父结点开始建堆 for i in reversed(range(len(nums) // 2)): adjust(nums, i, len(nums)) # 将最大结点交换至最后并调整堆 for i in reversed(range(len(nums))): nums[0], nums[i] = nums[i], nums[0] adjust(nums, 0, i) return nums  归并排序 #  归并排序的平均和最差情况时间均为  \\(O(n \\log n)\\)  ，空间为  \\(O(n)\\)  类似二叉树的 后序 遍历，先 recur 左右，再 visit 自己，所以迭代采用树的后序遍历模板\n递归形式 def merge_sort(nums: list) -\u0026gt; list: def merge(l1: list, l2: list) -\u0026gt; list: res = [] while l1 and l2: res.append(l1.pop(0) if l1[0] \u0026lt; l2[0] else l2.pop(0)) res.extend(l1 if l1 else l2) return res def recur(nums: list) -\u0026gt; list: if len(nums) \u0026lt;= 1: return nums mid = len(nums) // 2 return merge(recur(nums[:mid]), recur(nums[mid:])) return recur(nums) 迭代形式 def merge_sort_iter(nums: list) -\u0026gt; list: def merge(l1: list, l2: list) -\u0026gt; list: res = [] while l1 and l2: res.append(l1.pop(0) if l1[0] \u0026lt; l2[0] else l2.pop(0)) res.extend(l1 if l1 else l2) return res # 类似树的后序遍历，stack 里存 index 而不是 list 是因为这里每层迭代都需要上一次的结果，而不是缓存下来 stack = [(0, len(nums))] res = [] while stack: left, right = stack.pop() if left \u0026gt;= right - 1: continue mid = left + (right - left) // 2 res.append((left, mid, right)) stack.append((left, mid)) # 先入栈左半段 stack.append((mid, right)) # 再入栈右半段 for left, mid, right in reversed(res): nums[left:right] = merge(nums[left:mid], nums[mid:right]) return nums  快速排序 #  此方法为原地快排，平均时间均为  \\(O(n \\log n)\\)  ，最差情况  \\(O(n^2)\\)  ，空间为  \\(O(1)\\)  类似二叉树的 前序 遍历，先 visit 自己，再 recur 左右，所以迭代用栈替代即可\n递归形式 def quick_sort(nums: list): def partition(left, right): store = left for i in range(left, right): if nums[i] \u0026lt;= nums[right]: nums[store], nums[i] = nums[i], nums[store] store += 1 nums[store], nums[right] = nums[right], nums[store] return store def recur(left, right): if left \u0026gt;= right: return store = partition(left, right) recur(left, store - 1) recur(store + 1, right) recur(0, len(nums) - 1) return nums 迭代形式 def quick_sort_iter(nums: list): def partition(left, right): store = left for i in range(left, right): if nums[i] \u0026lt;= nums[right]: nums[store], nums[i] = nums[i], nums[store] store += 1 nums[store], nums[right] = nums[right], nums[store] return store stack = [(0, len(nums) - 1)] while stack: left, right = stack.pop() if left \u0026gt;= right: continue store = partition(left, right) stack.append((store + 1, right)) stack.append((left, store - 1)) return nums  "});})();