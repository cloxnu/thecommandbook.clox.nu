'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/algorithm/','title':"算法",'section':"Docs",'content':"算法 #  "});index.add({'id':1,'href':'/docs/algorithm/binary-tree/','title':"二叉树",'section':"算法",'content':"二叉树 #  二叉树 (Binary tree) 是每个节点最多只有两个分支的树结构。其结构定义如下：\nclass TreeNode: def __init__(self, value, left=None, right=None): self.value = value self.left = left self.right = right def visit(self): print(self.value, end=\u0026#34; \u0026#34;) # 访问当前结点 遍历 #  树的遍历 是图的遍历的一种，指的是按照某种规则，不重复地访问某种树的所有节点的过程。\n遍历可分为 深度优先遍历 和 广度优先遍历，深度优先遍历又分为 前序遍历 (Pre-Order Traversal)、中序遍历 (In-Order Traversal)、后序遍历 (Post-Order Traversal)；而广度优先搜索则对应 层序遍历。\n测试树如下：\n A / \\ B C / \\ / \\ D E F G / \\ H I 正确的前序遍历： A B D E C F H I G 正确的中序遍历： D B E A H F I C G 正确的后序遍历： D E B H I F G C A 正确的层序遍历： A B C D E F G H I test = TreeNode(\u0026#39;A\u0026#39;, left=TreeNode(\u0026#39;B\u0026#39;, left=TreeNode(\u0026#39;D\u0026#39;), right=TreeNode(\u0026#39;E\u0026#39;)),right=TreeNode(\u0026#39;C\u0026#39;, left=TreeNode(\u0026#39;F\u0026#39;, left=TreeNode(\u0026#39;H\u0026#39;), right=TreeNode(\u0026#39;I\u0026#39;)), right=TreeNode(\u0026#39;G\u0026#39;))) 递归形式 #  前序遍历 def preorder(node: TreeNode): if node is None: return node.visit() # 访问当前结点 preorder(node.left) preorder(node.right) 中序遍历 def inorder(node: TreeNode): if node is None: return inorder(node.left) node.visit() # 访问当前结点 inorder(node.right) 后序遍历 def postorder(node: TreeNode): if node is None: return postorder(node.left) postorder(node.right) node.visit() # 访问当前结点  迭代形式 #  栈模拟递归 #  前序遍历 1 def preorder_iter(root: TreeNode): if root is None: return stack = [root] while stack: node = stack.pop() if node is None: continue node.visit() # 访问当前结点 stack.append(node.right) # 先入栈右子树 stack.append(node.left) # 再入栈左子树 后序遍历 1 后序遍历 1：类前序遍历 1 + reverse：先用栈模拟，再利用双栈将 根-右-左 的结果反过来\ndef postorder_iter(root: TreeNode): if root is None: return stack = [root] res = [] while stack: node = stack.pop() if node is None: continue res.append(node) stack.append(node.left) # 先入栈左子树 stack.append(node.right) # 再入栈右子树 for node in reversed(res): node.visit()  迭代遍历模板 #  前序遍历 2 def preorder_iter2(root: TreeNode): if root is None: return stack = [] node = root while node or stack: while node: # 先找最左的 node，路途依次入栈 node.visit() # 根 stack.append(node) node = node.left # 左 node = stack.pop() node = node.right # 右 中序遍历 def inorder_iter(root: TreeNode): if root is None: return stack = [] node = root while node or stack: while node: # 先找最左的 node，路途依次入栈 stack.append(node) node = node.left # 左 node = stack.pop() node.visit() # 根 node = node.right # 右 后序遍历 2 后序遍历 2：类前序遍历 2 + reverse：先用树的非递归模板，再利用双栈将 根-右-左 的结果反过来\ndef postorder_iter2(root: TreeNode): if root is None: return stack, res = [], [] node = root while node or stack: while node: # 先找最右的 node，路途依次入栈 res.append(node) # 根 stack.append(node) node = node.right # 右 node = stack.pop() node = node.left # 左 for node in reversed(res): node.visit() 层序遍历 def levelorder_iter(root: TreeNode): if root is None: return queue = [root] while queue: node = queue.pop(0) node.visit() if node.left is not None: queue.append(node.left) if node.right is not None: queue.append(node.right)  "});index.add({'id':2,'href':'/docs/algorithm/mono-stack/','title':"单调栈",'section':"算法",'content':"单调栈 #  为什么要用单调栈？单调栈的作用是什么？\n单调栈能在   \\(O(n)\\)  时间内找到一个 list 中所有值左边第一次比它大/小的元素和右边第一个比它大/小的元素\n举个例子，[2, 3, 4, 7, 8, 6, 0, 1] 中 \u0026ldquo;2\u0026rdquo; 右边第一个比它小的元素是 \u0026ldquo;0\u0026rdquo;, \u0026ldquo;6\u0026rdquo; 右边第一个比它小的元素是 \u0026ldquo;0\u0026rdquo; 左边第一个比它小的元素是 \u0026ldquo;4\u0026rdquo;\n以下 left right 数组存的是左边比当前元素大/小的元素的下标，右边比当前元素大/小的元素的下标\n若要求左右边比原数小的值，则用单调递增栈，得到的 left right 数组是 (-1 代表左边没有更小的了，8 代表右边没有更小的了)\nleft = [-1, 0, 1, 2, 3, 2, -1, 6]；right = [6, 6, 6, 5, 5, 6, 8, 8]\n若要求左右边比原数大的值，则用单调递减栈，得到的 left right 数组是 (-1 代表左边没有更大的了，8 代表右边没有更大的了)\nleft = [-1, -1, -1, -1, -1, 4, 5, 5]；right = [1, 2, 3, 4, 8, 8, 7, 8]\n它们的应用在这里\n42. 接雨水\n84. 柱状图中最大的矩形\n单调递增栈 单调递增栈：找左右比当前元素小的元素\ndef mono_increasing_stack(nums: list) -\u0026gt; (list, list): stack = [] left, right = [-1] * len(nums), [len(nums)] * len(nums) # 默认左边全为 -1，右边全为 8 for i in range(len(nums)): while stack and nums[stack[-1]] \u0026gt; nums[i]: # 当当前元素非递增了，就 pop 栈顶元素 top = stack.pop() right[top] = i # 当前元素把 top 弹出来了，说明当前元素是 top 右边第一个比它小的元素 left[i] = stack[-1] if stack else -1 # 当前左边第一个比它小的元素就是栈里剩下它弹不了的元素了，如果栈空了，那左边就没有更小的了 stack.append(i) return left, right 单调递减栈 单调递减栈：找左右比当前元素大的元素\ndef mono_decreasing_stack(nums: list) -\u0026gt; (list, list): stack = [] left, right = [-1] * len(nums), [len(nums)] * len(nums) for i in range(len(nums)): while stack and nums[stack[-1]] \u0026lt; nums[i]: top = stack.pop() right[top] = i left[i] = stack[-1] if stack else -1 stack.append(i) return left, right  "});index.add({'id':3,'href':'/docs/algorithm/sorting/','title':"排序",'section':"算法",'content':"排序 #  排序算法 是一种能将一串资料依照特定排序方式进行排列的一种算法。\n堆排序 #  堆排序 (Heapsort) 是指利用堆这种数据结构所设计的一种排序算法。堆排序的平均和最差情况时间均为   \\(O(n \\log n)\\)  ，空间为  \\(O(1)\\)  递归形式 def heap_sort(nums: list) -\u0026gt; list: def adjust(heap: list, start, end): left = start * 2 + 1 right = left + 1 if left \u0026gt;= end: return max_child = right if right \u0026lt; end and heap[left] \u0026lt; heap[right] else left # 选取最大的子结点 if heap[start] \u0026lt; heap[max_child]: heap[start], heap[max_child] = heap[max_child], heap[start] adjust(heap, max_child, end) # 从最后一个结点的父结点开始建堆 for i in reversed(range(len(nums) // 2)): adjust(nums, i, len(nums)) # 将最大结点交换至最后并调整堆 for i in reversed(range(len(nums))): nums[0], nums[i] = nums[i], nums[0] adjust(nums, 0, i) return nums 迭代形式 def heap_sort_iter(nums: list) -\u0026gt; list: def adjust(heap: list, start, end): while start \u0026lt; end: left = start * 2 + 1 right = left + 1 if left \u0026gt;= end: break max_child = right if right \u0026lt; end and heap[left] \u0026lt; heap[right] else left # 选取最大的子结点 if heap[start] \u0026gt;= heap[max_child]: break heap[start], heap[max_child] = heap[max_child], heap[start] start = max_child # 从最后一个结点的父结点开始建堆 for i in reversed(range(len(nums) // 2)): adjust(nums, i, len(nums)) # 将最大结点交换至最后并调整堆 for i in reversed(range(len(nums))): nums[0], nums[i] = nums[i], nums[0] adjust(nums, 0, i) return nums  归并排序 #  归并排序 (Merge sort) 是创建在归并操作上的一种有效的排序算法。归并排序的平均和最差情况时间均为  \\(O(n \\log n)\\)  ，空间为  \\(O(n)\\)  类似二叉树的 后序 遍历，先 recur 左右，再 visit 自己，所以迭代采用树的后序遍历模板\n递归形式 def merge_sort(nums: list) -\u0026gt; list: def merge(l1: list, l2: list) -\u0026gt; list: res = [] while l1 and l2: res.append(l1.pop(0) if l1[0] \u0026lt; l2[0] else l2.pop(0)) res.extend(l1 if l1 else l2) return res def recur(nums: list) -\u0026gt; list: if len(nums) \u0026lt;= 1: return nums mid = len(nums) // 2 return merge(recur(nums[:mid]), recur(nums[mid:])) return recur(nums) 迭代形式 def merge_sort_iter(nums: list) -\u0026gt; list: def merge(l1: list, l2: list) -\u0026gt; list: res = [] while l1 and l2: res.append(l1.pop(0) if l1[0] \u0026lt; l2[0] else l2.pop(0)) res.extend(l1 if l1 else l2) return res # 类似树的后序遍历，stack 里存 index 而不是 list 是因为这里每层迭代都需要上一次的结果，而不是缓存下来 stack = [(0, len(nums))] res = [] while stack: left, right = stack.pop() if left \u0026gt;= right - 1: continue mid = left + (right - left) // 2 res.append((left, mid, right)) stack.append((left, mid)) # 先入栈左半段 stack.append((mid, right)) # 再入栈右半段 for left, mid, right in reversed(res): nums[left:right] = merge(nums[left:mid], nums[mid:right]) return nums  快速排序 #  快速排序 (Quicksort)，又称分区交换排序 (partition-exchange sort)。此方法为原地快排，平均时间均为  \\(O(n \\log n)\\)  ，最差情况  \\(O(n^2)\\)  ，空间为  \\(O(1)\\)  类似二叉树的 前序 遍历，先 visit 自己，再 recur 左右，所以迭代用栈替代即可\n递归形式 def quick_sort(nums: list): def partition(left, right): store = left for i in range(left, right): if nums[i] \u0026lt;= nums[right]: nums[store], nums[i] = nums[i], nums[store] store += 1 nums[store], nums[right] = nums[right], nums[store] return store def recur(left, right): if left \u0026gt;= right: return store = partition(left, right) recur(left, store - 1) recur(store + 1, right) recur(0, len(nums) - 1) return nums 迭代形式 def quick_sort_iter(nums: list): def partition(left, right): store = left for i in range(left, right): if nums[i] \u0026lt;= nums[right]: nums[store], nums[i] = nums[i], nums[store] store += 1 nums[store], nums[right] = nums[right], nums[store] return store stack = [(0, len(nums) - 1)] while stack: left, right = stack.pop() if left \u0026gt;= right: continue store = partition(left, right) stack.append((store + 1, right)) stack.append((left, store - 1)) return nums  "});})();