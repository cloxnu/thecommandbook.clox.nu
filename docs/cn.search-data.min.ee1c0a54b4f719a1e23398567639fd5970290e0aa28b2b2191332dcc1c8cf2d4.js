'use strict';(function(){const indexCfg={encode:false,tokenize:function(str){return str.replace(/[\x00-\x7F]/g,'').split('');}};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/algorithm/','title':"算法",'section':"Docs",'content':"算法 #  "});index.add({'id':1,'href':'/docs/algorithm/kmp/','title':"KMP 算法",'section':"算法",'content':"KMP 算法 #  Knuth-Morris-Pratt 字符串查找算法 （简称为 KMP 算法）可在一个字符串 S 内查找一个词 W 的出现位置。一个词在不匹配时本身就包含足够的信息来确定下一个匹配可能的开始位置，此算法利用这一特性以避免重新检查先前匹配的字符。\n以下示例是在 s 中寻找 p\n样例：\n   p a b a b a b c a     idx 0 1 2 3 4 5 6 7   PMT 0 0 1 2 3 4 0 1   next -1 0 0 1 2 3 4 0    PMT (Partial Match Table) 部分匹配表，是指字符串的前缀集合与后缀集合的交集中最长元素的长度\n比如 ababab 的所有前缀集合和后缀集合中交集最长元素是 前四个 \u0026ldquo;abab\u0026rdquo; 和后四个 \u0026ldquo;abab\u0026rdquo;，所以 idx 为 5 的 \u0026lsquo;b\u0026rsquo; 的 PMT 为 4\nnext 数组是指，当当前 pattern 指针指向的值失配时，需要将当前指针指向对应索引的值继续匹配\ndef get_next(p: str) -\u0026gt; list: next = [0] * len(p) next[0] = -1 i, j = 0, -1 while i \u0026lt; len(p) - 1: if j == -1 or p[i] == p[j]: i += 1 j += 1 next[i] = j else: j = next[j] return next def kmp(s: str, p: str) -\u0026gt; int: i, j = 0, 0 next = get_next(p) while i \u0026lt; len(s) and j \u0026lt; len(p): # print(i, s[i], j, p[j]) if j == -1 or s[i] == p[j]: i += 1 j += 1 else: j = next[j] # 失配，调转去 next 里指向的值继续匹配 if j == len(p): # 匹配成功 return i - j return -1 "});index.add({'id':2,'href':'/docs/algorithm/binary-tree/','title':"二叉树",'section':"算法",'content':"二叉树 #  二叉树 (Binary tree) 是每个节点最多只有两个分支的树结构。其结构定义如下：\nclass TreeNode: def __init__(self, value, left=None, right=None): self.value = value self.left = left self.right = right def visit(self): print(self.value, end=\u0026#34; \u0026#34;) # 访问当前结点 遍历 #  树的遍历 是图的遍历的一种，指的是按照某种规则，不重复地访问某种树的所有节点的过程。\n遍历可分为 深度优先遍历 和 广度优先遍历，深度优先遍历又分为 前序遍历 (Pre-Order Traversal)、中序遍历 (In-Order Traversal)、后序遍历 (Post-Order Traversal)；而广度优先搜索则对应 层序遍历。\n测试树如下：\n A / \\ B C / \\ / \\ D E F G / \\ H I 正确的前序遍历： A B D E C F H I G 正确的中序遍历： D B E A H F I C G 正确的后序遍历： D E B H I F G C A 正确的层序遍历： A B C D E F G H I test = TreeNode(\u0026#39;A\u0026#39;, left=TreeNode(\u0026#39;B\u0026#39;, left=TreeNode(\u0026#39;D\u0026#39;), right=TreeNode(\u0026#39;E\u0026#39;)),right=TreeNode(\u0026#39;C\u0026#39;, left=TreeNode(\u0026#39;F\u0026#39;, left=TreeNode(\u0026#39;H\u0026#39;), right=TreeNode(\u0026#39;I\u0026#39;)), right=TreeNode(\u0026#39;G\u0026#39;))) 递归形式 #  前序遍历 def preorder(node: TreeNode): if node is None: return node.visit() # 访问当前结点 preorder(node.left) preorder(node.right) 中序遍历 def inorder(node: TreeNode): if node is None: return inorder(node.left) node.visit() # 访问当前结点 inorder(node.right) 后序遍历 def postorder(node: TreeNode): if node is None: return postorder(node.left) postorder(node.right) node.visit() # 访问当前结点  迭代形式 #  栈模拟递归 #  前序遍历 1 def preorder_iter(root: TreeNode): if root is None: return stack = [root] while stack: node = stack.pop() if node is None: continue node.visit() # 访问当前结点 stack.append(node.right) # 先入栈右子树 stack.append(node.left) # 再入栈左子树 后序遍历 1 后序遍历 1：类前序遍历 1 + reverse：先用栈模拟，再利用双栈将 根-右-左 的结果反过来\ndef postorder_iter(root: TreeNode): if root is None: return stack = [root] res = [] while stack: node = stack.pop() if node is None: continue res.append(node) stack.append(node.left) # 先入栈左子树 stack.append(node.right) # 再入栈右子树 for node in reversed(res): node.visit()  迭代遍历模板 #  前序遍历 2 def preorder_iter2(root: TreeNode): if root is None: return stack = [] node = root while node or stack: while node: # 先找最左的 node，路途依次入栈 node.visit() # 根 stack.append(node) node = node.left # 左 node = stack.pop() node = node.right # 右 中序遍历 def inorder_iter(root: TreeNode): if root is None: return stack = [] node = root while node or stack: while node: # 先找最左的 node，路途依次入栈 stack.append(node) node = node.left # 左 node = stack.pop() node.visit() # 根 node = node.right # 右 后序遍历 2 后序遍历 2：类前序遍历 2 + reverse：先用树的非递归模板，再利用双栈将 根-右-左 的结果反过来\ndef postorder_iter2(root: TreeNode): if root is None: return stack, res = [], [] node = root while node or stack: while node: # 先找最右的 node，路途依次入栈 res.append(node) # 根 stack.append(node) node = node.right # 右 node = stack.pop() node = node.left # 左 for node in reversed(res): node.visit() 层序遍历 def levelorder_iter(root: TreeNode): if root is None: return queue = [root] while queue: node = queue.pop(0) node.visit() if node.left is not None: queue.append(node.left) if node.right is not None: queue.append(node.right)  "});index.add({'id':3,'href':'/docs/algorithm/mono-stack/','title':"单调栈",'section':"算法",'content':"单调栈 #  为什么要用单调栈？单调栈的作用是什么？\n单调栈能在   \\(O(n)\\)  时间内找到一个 list 中所有值左边第一次比它大/小的元素和右边第一个比它大/小的元素\n举个例子，[2, 3, 4, 7, 8, 6, 0, 1] 中 \u0026ldquo;2\u0026rdquo; 右边第一个比它小的元素是 \u0026ldquo;0\u0026rdquo;, \u0026ldquo;6\u0026rdquo; 右边第一个比它小的元素是 \u0026ldquo;0\u0026rdquo; 左边第一个比它小的元素是 \u0026ldquo;4\u0026rdquo;\n以下 left right 数组存的是左边比当前元素大/小的元素的下标，右边比当前元素大/小的元素的下标\n若要求左右边比原数小的值，则用单调递增栈，得到的 left right 数组是 (-1 代表左边没有更小的了，8 代表右边没有更小的了)\nleft = [-1, 0, 1, 2, 3, 2, -1, 6]；right = [6, 6, 6, 5, 5, 6, 8, 8]\n若要求左右边比原数大的值，则用单调递减栈，得到的 left right 数组是 (-1 代表左边没有更大的了，8 代表右边没有更大的了)\nleft = [-1, -1, -1, -1, -1, 4, 5, 5]；right = [1, 2, 3, 4, 8, 8, 7, 8]\n它们的应用在这里\n42. 接雨水\n84. 柱状图中最大的矩形\n单调递增栈 单调递增栈：找左右比当前元素小的元素\ndef mono_increasing_stack(nums: list) -\u0026gt; (list, list): stack = [] left, right = [-1] * len(nums), [len(nums)] * len(nums) # 默认左边全为 -1，右边全为 8 for i in range(len(nums)): while stack and nums[stack[-1]] \u0026gt; nums[i]: # 当当前元素非递增了，就 pop 栈顶元素 top = stack.pop() right[top] = i # 当前元素把 top 弹出来了，说明当前元素是 top 右边第一个比它小的元素 left[i] = stack[-1] if stack else -1 # 当前左边第一个比它小的元素就是栈里剩下它弹不了的元素了，如果栈空了，那左边就没有更小的了 stack.append(i) return left, right 单调递减栈 单调递减栈：找左右比当前元素大的元素\ndef mono_decreasing_stack(nums: list) -\u0026gt; (list, list): stack = [] left, right = [-1] * len(nums), [len(nums)] * len(nums) for i in range(len(nums)): while stack and nums[stack[-1]] \u0026lt; nums[i]: top = stack.pop() right[top] = i left[i] = stack[-1] if stack else -1 stack.append(i) return left, right  "});index.add({'id':4,'href':'/docs/algorithm/union-find/','title':"并查集",'section':"算法",'content':"并查集 #  并查集 | 维基百科\n实现「加权规则」和「折叠规则」\n使用并查集，轻松秒掉 200. 岛屿数量\n本算法时间复杂度为   \\(O(n \\alpha(n))\\)  .  \\(\\alpha(n)\\)  是反阿克曼函数，当自变量 n 的值在人类可观测的范围内（宇宙中粒子的数量）时，函数  \\(\\alpha(n)\\)  的值不会超过 5，因此也可以看成是常数时间复杂度。\nclass UnionFind: def __init__(self, all_data: list): \u0026#34;\u0026#34;\u0026#34; 初始化并查集 :param all_data: 数据列表 \u0026#34;\u0026#34;\u0026#34; self.parent = {} self.size = {} self.union_num = 0 for data in all_data: self.parent[data] = data # 初始父亲结点为自己 self.size[data] = 1 self.union_num += 1 def __repr__(self): return \u0026#34;parent: {}\\nsize: {}\\nunion_num: {}\\n\u0026#34;.format(self.parent, self.size, self.union_num) def add(self, *will_add_data): for data in will_add_data: if data not in self.parent: self.parent[data] = data self.size[data] = 1 self.union_num += 1 def find(self, data): \u0026#34;\u0026#34;\u0026#34; 查找 data 属于哪个集合，返回 root :param data: 要查询的值 :return: data 属于的集合的 root \u0026#34;\u0026#34;\u0026#34; if data not in self.parent: return None node = data # 防止引用类型的 data 被改变 nodes = [] # 将路上的 node 全部记下来 while self.parent[node] != node: nodes.append(node) node = self.parent[node] for n in nodes: # 将路上的 node 的父结点全部指向根结点以满足「折叠规则」 self.parent[n] = node self.size[n] = 1 return node def union(self, *will_union_data): \u0026#34;\u0026#34;\u0026#34; 合并多个值，当值不存在时跳过 :param will_union_data: 要合并的值 \u0026#34;\u0026#34;\u0026#34; root1 = None # 第一个要合并集合的 root for data in will_union_data: root2 = self.find(data) if root1 is None: root1 = root2 # 将 will_union_data 中第一个 data 的 root 赋值给 root1 if root2 is None or root1 == root2: continue # size 小的集合合并到 size 大的集合 if self.size[root1] \u0026gt;= self.size[root2]: self.parent[root2] = root1 self.size[root1] += self.size[root2] else: self.parent[root1] = root2 self.size[root2] += self.size[root1] root1 = root2 # 更新 root1 为新的 root self.union_num -= 1 "});index.add({'id':5,'href':'/docs/algorithm/sorting/','title':"排序",'section':"算法",'content':"排序 #  排序算法 是一种能将一串资料依照特定排序方式进行排列的一种算法。\n堆排序 #  堆排序 (Heapsort) 是指利用堆这种数据结构所设计的一种排序算法。堆排序的平均和最差情况时间均为   \\(O(n \\log n)\\)  ，空间为  \\(O(1)\\)  递归形式 def heap_sort(nums: list) -\u0026gt; list: def adjust(heap: list, start, end): left = start * 2 + 1 right = left + 1 if left \u0026gt;= end: return max_child = right if right \u0026lt; end and heap[left] \u0026lt; heap[right] else left # 选取最大的子结点 if heap[start] \u0026lt; heap[max_child]: heap[start], heap[max_child] = heap[max_child], heap[start] adjust(heap, max_child, end) # 从最后一个结点的父结点开始建堆 for i in reversed(range(len(nums) // 2)): adjust(nums, i, len(nums)) # 将最大结点交换至最后并调整堆 for i in reversed(range(len(nums))): nums[0], nums[i] = nums[i], nums[0] adjust(nums, 0, i) return nums 迭代形式 def heap_sort_iter(nums: list) -\u0026gt; list: def adjust(heap: list, start, end): while start \u0026lt; end: left = start * 2 + 1 right = left + 1 if left \u0026gt;= end: break max_child = right if right \u0026lt; end and heap[left] \u0026lt; heap[right] else left # 选取最大的子结点 if heap[start] \u0026gt;= heap[max_child]: break heap[start], heap[max_child] = heap[max_child], heap[start] start = max_child # 从最后一个结点的父结点开始建堆 for i in reversed(range(len(nums) // 2)): adjust(nums, i, len(nums)) # 将最大结点交换至最后并调整堆 for i in reversed(range(len(nums))): nums[0], nums[i] = nums[i], nums[0] adjust(nums, 0, i) return nums  归并排序 #  归并排序 (Merge sort) 是创建在归并操作上的一种有效的排序算法。归并排序的平均和最差情况时间均为  \\(O(n \\log n)\\)  ，空间为  \\(O(n)\\)  类似二叉树的 后序 遍历，先 recur 左右，再 visit 自己，所以迭代采用树的后序遍历模板\n递归形式 def merge_sort(nums: list) -\u0026gt; list: def merge(l1: list, l2: list) -\u0026gt; list: res = [] while l1 and l2: res.append(l1.pop(0) if l1[0] \u0026lt; l2[0] else l2.pop(0)) res.extend(l1 if l1 else l2) return res def recur(nums: list) -\u0026gt; list: if len(nums) \u0026lt;= 1: return nums mid = len(nums) // 2 return merge(recur(nums[:mid]), recur(nums[mid:])) return recur(nums) 迭代形式 def merge_sort_iter(nums: list) -\u0026gt; list: def merge(l1: list, l2: list) -\u0026gt; list: res = [] while l1 and l2: res.append(l1.pop(0) if l1[0] \u0026lt; l2[0] else l2.pop(0)) res.extend(l1 if l1 else l2) return res # 类似树的后序遍历，stack 里存 index 而不是 list 是因为这里每层迭代都需要上一次的结果，而不是缓存下来 stack = [(0, len(nums))] res = [] while stack: left, right = stack.pop() if left \u0026gt;= right - 1: continue mid = left + (right - left) // 2 res.append((left, mid, right)) stack.append((left, mid)) # 先入栈左半段 stack.append((mid, right)) # 再入栈右半段 for left, mid, right in reversed(res): nums[left:right] = merge(nums[left:mid], nums[mid:right]) return nums  快速排序 #  快速排序 (Quicksort)，又称分区交换排序 (partition-exchange sort)。此方法为原地快排，平均时间为  \\(O(n \\log n)\\)  ，最差情况  \\(O(n^2)\\)  ，空间为  \\(O(1)\\)  类似二叉树的 前序 遍历，先 visit 自己，再 recur 左右，所以迭代用栈替代即可\n递归形式 def quick_sort(nums: list): def partition(left, right): store = left for i in range(left, right): if nums[i] \u0026lt;= nums[right]: nums[store], nums[i] = nums[i], nums[store] store += 1 nums[store], nums[right] = nums[right], nums[store] return store def recur(left, right): if left \u0026gt;= right: return store = partition(left, right) recur(left, store - 1) recur(store + 1, right) recur(0, len(nums) - 1) return nums 迭代形式 def quick_sort_iter(nums: list): def partition(left, right): store = left for i in range(left, right): if nums[i] \u0026lt;= nums[right]: nums[store], nums[i] = nums[i], nums[store] store += 1 nums[store], nums[right] = nums[right], nums[store] return store stack = [(0, len(nums) - 1)] while stack: left, right = stack.pop() if left \u0026gt;= right: continue store = partition(left, right) stack.append((store + 1, right)) stack.append((left, store - 1)) return nums  "});index.add({'id':6,'href':'/docs/algorithm/knapsack/','title':"背包问题",'section':"算法",'content':"背包问题 #  背包问题 是一种组合优化的NP完全问题。问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。\n0-1 背包 #  0-1 背包\n有 n 个物品，物品有两个属性，代价 cost，价值 value，背包在容量 space 的限制下可以装物品的最大价值？\n假设物品数 n = 3；costs = [1, 2, 5]；values = [3, 7, 15]；space = 7\n   j \\ dp[j] \\ space 0 1 2 3 4 5 6 7     init 0 0 0 0 0 0 0 0   1 0 3 3 3 3 3 3 3   1+2 0 3 7 10 10 10 10 10   1+2+3 0 3 7 10 10 15 18 22    def zero_one_back(n: int, costs: list, values: list, space: int): dp = [0] * (space + 1) for i in range(n): # 0-1 背包问题中，这两层循环不可以交换 for j in reversed(range(space + 1)): if j \u0026lt; costs[i]: break # 这里因为 j 是有序的（越来越小），所以可以用 break，否则用 continue dp[j] = max(dp[j], dp[j - costs[i]] + values[i]) return dp[space] 完全背包 #  有 n 个物品，物品的数量无限，物品有两个属性，代价 cost，价值 value，背包在容量 space 的限制下可以装物品的最大价值？\n假设物品数 n = 3；costs = [1, 2, 5]；values = [3, 7, 15]；space = 7\n   j \\ dp[j] \\ space 0 1 2 3 4 5 6 7     init 0 0 0 0 0 0 0 0   1 0 3 6 9 12 15 18 21   1+2 0 3 7 10 14 17 21 24   1+2+3 0 3 7 10 14 17 21 24    def complete_back(n: int, costs: list, values: list, space: int): dp = [0] * (space + 1) for i in range(n): # 完全背包问题中，这两层循环可以交换 for j in range(space + 1): if j \u0026lt; costs[i]: continue # 这里是 continue dp[j] = max(dp[j], dp[j - costs[i]] + values[i]) print(dp) return dp[space] 装满 0-1 背包 #  有 n 个物品，物品有两个属性，代价 cost，价值 value，背包在容量 space 的限制下可以装物品的最 小 价值（要求背包必须装满）？\n思路：初始化时将除 0 以外的数定义为 \u0026lsquo;inf\u0026rsquo;，代表背包无法装到这个容量，若题目改为最大，则初始化为 \u0026lsquo;-inf\u0026rsquo;，并将 min 改为 max 即可\n假设物品数 n = 4；costs = [2, 3, 5, 7]；values = [3, 5, 7, 9]；space = 10\n   j \\ dp[j] \\ space 0 1 2 3 4 5 6 7 8 9 10     init 0 inf inf inf inf inf inf inf inf inf inf   1 0 inf 3 inf inf inf inf inf inf inf inf   1+2 0 inf 3 5 inf 8 inf inf inf inf inf   1+2+3 0 inf 3 5 inf 7 inf 10 12 inf 15   1+2+3+4 0 inf 3 5 inf 7 inf 9 12 12 14    def filled_zero_one_back(n: int, costs: list, values: list, space: int): dp = [float(\u0026#39;inf\u0026#39;)] * (space + 1) dp[0] = 0 for i in range(n): # 0-1 背包问题中，这两层循环不可以交换 for j in reversed(range(space + 1)): if j \u0026lt; costs[i]: break # 这里因为 j 是有序的（越来越小），所以可以用 break，否则用 continue dp[j] = min(dp[j], dp[j - costs[i]] + values[i]) print(dp) return dp[space] 装满完全背包 #  有 n 个物品，物品的数量无限，物品有两个属性，代价 cost，价值 value，背包在容量 space 的限制下可以装物品的最 小 价值（要求背包必须装满）？\n思路：初始化时将除 0 以外的数定义为 \u0026lsquo;inf\u0026rsquo;，代表背包无法装到这个容量，若题目改为最大，则初始化为 \u0026lsquo;-inf\u0026rsquo;，并将 min 改为 max 即可\n假设物品数 n = 4；costs = [2, 3, 5, 7]；values = [3, 5, 7, 9]；space = 10\n   j \\ dp[j] \\ space 0 1 2 3 4 5 6 7 8 9 10     init 0 inf inf inf inf inf inf inf inf inf inf   1 0 inf 3 inf 6 inf 9 inf 12 inf 15   1+2(1) 0 inf 3 5 6 inf 9 inf 12 15 15   1+2(2) 0 inf 3 5 6 8 9 11 12 14 15   1+2+3 0 inf 3 5 6 7 9 10 12 13 14   1+2+3+4 0 inf 3 5 6 7 9 9 12 12 14    def filled_complete_back(n: int, costs: list, values: list, space: int): dp = [float(\u0026#39;inf\u0026#39;)] * (space + 1) dp[0] = 0 for i in range(n): # 完全背包问题中，这两层循环可以交换 for j in range(space + 1): if j \u0026lt; costs[i]: continue # 这里是 continue dp[j] = min(dp[j], dp[j - costs[i]] + values[i]) print(dp) return dp[space] "});index.add({'id':7,'href':'/docs/algorithm/linked-list/','title':"链表",'section':"算法",'content':"链表 #  链表 (Linked list) 是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针 (Pointer)。链表的程序定义如下：\nclass ListNode: def __init__(self, x, next=None): self.val = x self.next = next 1. 环形链表 #  检测链表中的环\n141. 环形链表\n1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 4 | | 7 \u0026lt;- 6 \u0026lt;- 5 快慢指针，相撞即有环\ndef hasCycle(head: ListNode) -\u0026gt; bool: slow = fast = head while fast and fast.next: fast = fast.next.next slow = slow.next if fast == slow: return True return False 2. 环形链表 II #  检测链表中的环，并输出入环的第一个结点，无环返回 None\n142. 环形链表 II\n先快慢指针检测是否有环，然后将 ptr 放到 head，同时开始 ptr 和 slow，相撞的点即为入环点\n证明：设入环点前长度为   \\(a\\)  ，slow 走过的路程为  \\(a \u0026#43; b\\)  ，fast 走过的路程为  \\(a \u0026#43; n(b \u0026#43; c) \u0026#43; b\\)  （ \\(n\\)  为圈数， \\(b \u0026#43; c\\)  为环长），fast 的路程一定是 slow 的两倍，所以  \\(a \u0026#43; n(b \u0026#43; c) \u0026#43; b = 2a \u0026#43; 2b\\)  ，所以  \\(a = (n - 1)(b \u0026#43; c) \u0026#43; c\\)  def detectCycle(head: ListNode) -\u0026gt; ListNode or None: slow = fast = head while fast and fast.next: fast = fast.next.next slow = slow.next if fast == slow: ptr = head while ptr != slow: slow = slow.next ptr = ptr.next return ptr return None 3. 相交链表 #  找到两个单链表相交的起始结点\n160. 相交链表\n1 -\u0026gt; 2 -\u0026gt; 3 | 4 -\u0026gt; 5 -\u0026gt; 6 -\u0026gt; 7 双指针，相遇，时间  \\(O(n)\\)  空间  \\(O(1)\\)  def getIntersectionNode(headA: ListNode, headB: ListNode) -\u0026gt; ListNode or None: nodeA, nodeB = headA, headB while nodeA != nodeB: nodeA = nodeA.next if nodeA else headB nodeB = nodeB.next if nodeB else headA return nodeA 4. 链表的中间结点 #  找出单链表的中间结点\n876. 链表的中间结点\n1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 4 -\u0026gt; 5 | 快慢指针，快的到链表尾，慢的即在中点\ndef middleNode(head: ListNode) -\u0026gt; ListNode: slow = fast = head while fast and fast.next: fast = fast.next.next slow = slow.next return slow 5. 反转链表 #  反转一个单链表\n206. 反转链表\n双指针\ndef reverseList(head: ListNode) -\u0026gt; ListNode: pre, curr = None, head while curr: curr.next, pre, curr = pre, curr, curr.next return pre 6. K 个一组反转链表 #  困难；将一个链表每 k 个结点一组进行反转，返回反转后的链表\ninput: 1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 4 -\u0026gt; 5; k = 2 output: 2 -\u0026gt; 1 -\u0026gt; 4 -\u0026gt; 3 -\u0026gt; 5 时间  \\(O(n)\\)  空间  \\(O(1)\\)  def reverseKGroup(head: ListNode, k: int) -\u0026gt; ListNode: def reverse(one_head: ListNode, one_tail: ListNode) -\u0026gt; (ListNode, ListNode): pre, curr = None, one_head while pre != one_tail: curr.next, pre, curr = pre, curr, curr.next return one_tail, one_head pre = dummy = ListNode(0, next=head) curr = head while curr: for _ in range(k - 1): curr = curr.next if curr is None: return dummy.next one_head, one_tail, curr = pre.next, curr, curr.next # 确定下一步要 reverse 的头尾 one_head, one_tail = reverse(one_head, one_tail) # reverse pre.next, one_tail.next = one_head, curr # 连接 pre = one_tail # 把 pre 移动到下一次的位置 return dummy.next 7. 合并两个有序链表 #  input: 1 -\u0026gt; 2 -\u0026gt; 4; 1 -\u0026gt; 3 -\u0026gt; 4 output: 1 -\u0026gt; 1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 4 -\u0026gt; 4 def mergeTwoLists(l1: ListNode, l2: ListNode) -\u0026gt; ListNode: n1 = dummy = ListNode(0, next=l1) n2 = l2 while n1.next and n2: if n1.next.val \u0026gt;= n2.val: n1.next, n2 = n2, n1.next n1 = n1.next if n2: n1.next = n2 return dummy.next 8. 合并 K 个有序链表 #  input: 1 -\u0026gt; 4 -\u0026gt; 5; 1 -\u0026gt; 3 -\u0026gt; 4; 2 -\u0026gt; 6 output: 1 -\u0026gt; 1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 4 -\u0026gt; 4 -\u0026gt; 5 -\u0026gt; 6 def mergeKLists(lists: list) -\u0026gt; ListNode: def merge2Lists(l1: ListNode, l2: ListNode) -\u0026gt; ListNode: n1 = dummy = ListNode(0, next=l1) n2 = l2 while n1.next and n2: if n1.next.val \u0026gt;= n2.val: n1.next, n2 = n2, n1.next n1 = n1.next if n2: n1.next = n2 return dummy.next def recur(ls: list) -\u0026gt; ListNode: if len(ls) == 0: return None if len(ls) == 1: return ls[0] mid = len(ls) // 2 return merge2Lists(recur(ls[:mid]), recur(ls[mid:])) return recur(lists) "});})();